= Usage tutorial

Writing simplified Markdown parser

=== Intro

In this section we will parse subset of Markdown
syntax with library constructs. We will skip parsing
code blocks and thematic breaks leaving only 4 productions.

----
MarkdownDocument  ::=  Block*
Block             ::=  HeadingBlock
                   |  Paragraph
                   |  BlockQuote
                   |  BlankLine
----

Heading block will start with multiplicity of '#' and end with a newline.

----
ATXHeading      ::=  "#"{1, 6} [Space] Text LineBreak
----

On the other hand paragraph will allow single line breaks which will be not
considered after parsing. It will allow for formatting text with common markdown
punctuation.

----
Paragraph       ::=  (InlineContent (Space | LineBreak)*)+
----


Block quote consists of text lines prefixed by '>'

----
BlockQuote      ::=  (">" [Space] Text LineBreak)+
----

We will also need blank lines to separate text blocks:

----
BlankLine       ::=  (Space | Tab)* LineBreak
----

And finally the inline content is as follows:

----
InlineContent    ::=  InlineElement*
InlineElement    ::=  Text
                   |  Emphasis
                   |  Strong
                   |  InlineCode
                   |  Link
----

Text is unicode characters without markdown punctuation.

----
Emphasis ::= `"*" Text "*"
Strong = "**" Text "**"
InlineCode  = "`" Text "`"
Link   =  "[" Text "]" "(" Text ")"
----

=== Parsing inline elements

So the text element are plain characters without the puctuation of markdown. First
we write a rule for single char. `noneOf` matches any of the characters that is not specified.
Then we will take many occurences with the requirement of at least one char present - `some`.
`some()` returns a list of chars so we have to map it to string - a `str()` method does that.

[source, java]
----
public void main(String[] args) {
    var textSingle = noneOf('*', '`', '[', ']', '(', ')', '>', '\n');

    var text = some(textSingle).str();

    var r1 = text.parse("this some text");

    out.println(r1.ok());

}
----

Lets test that the punctuation is not parsed

[source, java]
----
public void main(String[] args) {
    var textSingle = noneOf('*', '`', '[', ']', '(', ')', '>', '\n');

    var text = some(textSingle).str();

    var r1 = text.parse("this some *text*");

    if (r1 instanceof Ok(String s, Context ctx)) {
        assert r1.ok().equals("this some ");
        assert ctx.index == ctx.content.indexOf("*");

    } else {
        throw new ParseException("unexpected");
    }

}
----

`some()` succeeded because we have at least one character matching, but
the text got parsed up to the first occurence of '*'. We will handle the error later.
To make the assertions inline we can use convenience methods on the result,
`assertEquals` which throw exception if condition not met.

[source, java]
----
public void main(String[] args) {
    var textSingle = noneOf('*', '`', '[', ']', '(', ')', '>', '\n');

    var text = some(textSingle).str();

    text.assertEquals(
        Context.of("this some *text*"), "this some ");

}
----

Moving to the next elements we can reuse the text rule. But first we
introduce sealed interface with records to hold variants.

[source, java]
----
sealed interface Inline {
    record Text(String value) implements Inline{};
    record Emphasis(String value) implements Inline{};
    record Strong(String value) implements Inline{};
    record Code(String value) implements Inline{};
    record Link(String text, String url) implements Inline{};
}
----

We have to "capture" the char '*' on start and end and text goes in the middle.
The we will take the middle value from `Tuple3` and map it to constructor.

[source, java]
----

var emphasis = seq(c('*'), text, c('*'))
    .map(Ops::takeMiddle).map(Inline.Text::new);

out.println(emphasis.parse("*emphasis*").ok());
----

We get:

`$ Text[value=emphasis]`

[source, java]
----
emphasis.assertFails("* emphasis `code`*");
----

In this way we make sure that everything is correct. Text gets only
parsed up to '`', but then we have to end the rule with '*' which is not matched.

We move on to the next rules and test them

[source, java]
----
public void main(String[] args) {
    var textSingle = noneOf('*', '`', '[', ']', '(', ')', '>', '\n');
    var text = some(textSingle).str();

    var emphasis = seq(c('*'), text, c('*'))
        .map(Ops::takeMiddle).map(Inline.Emphasis::new);

    emphasis.assertFails("* emphasis `code`*");
    emphasis.assertEquals(Context.of("*text*"),  new Inline.Emphasis("text"));

    var strong = seq(c("**"), text, c("**"))
        .map(Ops::takeMiddle).map(Inline.Strong::new);

    strong.assertFails("** strong *nested* **");
    strong.assertEquals(Context.of("**strong**"), new Inline.Strong("strong"));

    var codeText = some(noneOf('`', '\n')).str();
    var code = seq(c('`'), codeText, c('`'))
        .map(Ops::takeMiddle).map(Inline.Code::new);
    code.assertEquals(Context.of("`code ()*[]`"), new Inline.Code("code ()*[]"));

    var link = seq(c('['), text, c(']'), c('('), text, c(')'))
        .map( tuple6 -> new Inline.Link(tuple6.two(), tuple6.five()));
    link.assertEquals(Context.of("[desc](https://link)"), new Inline.Link("desc", "https://link"));

    var inline = choice(link, strong, code, emphasis, text)
        .map(ch5 ->
            switch (ch5) {
                case One(Inline.Link l) -> (Inline) l;
                case Two(Inline.Strong s) -> (Inline) s;
                case Three(Inline.Code c) -> (Inline) c;
                case Four(Inline.Emphasis e) -> (Inline) e;
                case Five(String t) -> (Inline) new Inline.Text(t);
            }
        );

    var r2 = some(inline).parse("text with **strong** and `code`");
    out.println(r2.ok());

}
----

Which gets:

`$ [Text[value=text with ], Strong[value=strong], Text[value= and ], Code[value=code]]`

=== Parsing blocks

We move on to parsing on whole blocks. Lets start with the paragraph. It is any of the
inline elements which are separated by either mutliple spaces or a single newline.

[source, java]
----
var paragraph = sepBy(inline, (c('\n').or(some(c(' ')))));
var r3 = paragraph.parse("""
        normal text   *emphasis text*
        **strong text**
        `code text`
        """);
assert r3.isOk();
----

The block quote is a normal text without punctuation, but each starts with '>'.

[source, java]
----
 var blockQuote = sepBy(
    seq(c('>'), text)
        .map(Ops::takeSecond),
    c('\n')).map(list -> String.join(" ", list));

var r4 = blockQuote.parse("""
        first line
        second line
        """);
assert r4.ok().equals("first line second line");
----

Lets move on to separating paragraphs.

[source, java]
----
var blankLine = seq(many(c(' ')), c('\n'));

var r5 = sepBy(paragraph, blankLine).parse("""
        paragraph 1

        paragraph 2
        """);
assert r5.ok().size() == 2;
----

Each block quote element will be separated by blank line which consists only
of whitespace characters. So we use `sepBy` rule to gather all paragraphs in test.

Heading is a text prefixed by number of '#' s. Lets parse that.

[source, java]
----
var heading = seq(
        times(c('#'), 1, 6)
            .map(List::size),
        many(c(' ')),
        text
).map(p -> new Block.HeadingBlock(p.one(), p.three()));

heading.assertEquals(Context.of("## heading 2"), new Block.HeadingBlock(2, "heading 2"));
----

And now we are ready to combine everything together:

[source, java]
----
public void main(String[] args) {
    var textSingle = noneOf('*', '#', '`', '[', ']', '(', ')', '>', '\n');
    var text = some(textSingle).str();

    var emphasis = seq(c('*'), text, c('*'))
        .map(Ops::takeMiddle).map(Inline.Emphasis::new);

    emphasis.assertFails("* emphasis `code`*");
    emphasis.assertEquals(Context.of("*text*"),  new Inline.Emphasis("text"));

    var strong = seq(c("**"), text, c("**"))
        .map(Ops::takeMiddle).map(Inline.Strong::new);

    strong.assertFails("** strong *nested* **");
    strong.assertEquals(Context.of("**strong**"), new Inline.Strong("strong"));

    var codeText = some(noneOf('`', '\n')).str();
    var code = seq(c('`'), codeText, c('`'))
        .map(Ops::takeMiddle).map(Inline.Code::new);
    code.assertEquals(Context.of("`code ()*[]`"), new Inline.Code("code ()*[]"));

    var link = seq(c('['), text, c(']'), c('('), text, c(')'))
        .map( tuple6 -> new Inline.Link(tuple6.two(), tuple6.five()));
    link.assertEquals(Context.of("[desc](https://link)"), new Inline.Link("desc", "https://link"));

    var inline = choice(link, strong, code, emphasis, text)
        .map(ch5 ->
            switch (ch5) {
                case One(Inline.Link l) -> (Inline) l;
                case Two(Inline.Strong s) -> (Inline) s;
                case Three(Inline.Code c) -> (Inline) c;
                case Four(Inline.Emphasis e) -> (Inline) e;
                case Five(String t) -> (Inline) new Inline.Text(t);
            }
        );


    var paragraph = sepBy(inline, (c('\n').or(many(c(' ')))))
         .map(Block.Paragraph::new);
    var r3 = paragraph.parse("""
            normal text   *emphasis text*
            **strong text**
            `code text`
            """);
    assert r3.isOk();

    var blockQuote = sepBy(
        seq(c('>'), text)
            .map(Ops::takeSecond),
        c('\n')).map(list -> String.join(" ", list))
        .map(Block.BlockQoute::new);

    var r4 = blockQuote.parse("""
            first line
            second line
            """);
    assert r4.ok().equals(new Block.BlockQoute("first line second line"));

    var blankLine = seq(many(c(' ')), many(c('\n')));

    var r5 = sepBy(paragraph, blankLine).parse("""
            paragraph 1

            paragraph 2
            """);
    assert r5.ok().size() == 2;

    var heading = seq(
            times(c('#'), 1, 6)
                .map(List::size),
            many(c(' ')),
            text
    ).map(p -> new Block.Heading(p.one(), p.three()));

    heading.assertEquals(Context.of("## heading 2"), new Block.Heading(2, "heading 2"));

    var block = choice(blockQuote, paragraph, heading)
            .map(t3 -> switch(t3) {
                case One(Block.BlockQoute q) -> (Block) q;
                case Two(Block.Paragraph p) -> (Block) p;
                case Three(Block.Heading h) -> (Block) h;
            });

    var markdown = sepBy(block, blankLine);

    var test = """
            This is a **strong** paragraph.
            With `code`

            # Heading 1

            > Some interesting
            > quote
            """;

    out.println(markdown.parse(test).ok());
}
----

Result:

----
$ [Paragraph[elements=[Text[value=This is a ], Strong[value=strong], Text[value=paragraph.], Text[value=With ], Code[value=code]]], Heading[nestLevel=1, text=Heading 1], BlockQoute[text= Some interesting  quote]]
----


