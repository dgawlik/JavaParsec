= Usage tutorial

Writing simplified Markdown parser

=== Intro

In this section we will parse subset of Markdown
syntax with library constructs. We will skip parsing
code blocks and thematic breaks leaving only 4 productions.

----
MarkdownDocument  ::=  Block*
Block             ::=  HeadingBlock
                   |  Paragraph
                   |  BlockQuote
                   |  BlankLine
----

Heading block will start with multiplicity of '#' and end with a newline.

----
ATXHeading      ::=  "#"{1, 6} [Space] Text LineBreak
----

On the other hand paragraph will allow single line breaks which will be not
considered after parsing. It will allow for formatting text with common markdown
punctuation.

----
Paragraph       ::=  (InlineContent (Space | LineBreak)*)+
----


Block quote consists of text lines prefixed by '>'

----
BlockQuote      ::=  (">" [Space] Text LineBreak)+
----

We will also need blank lines to separate text blocks:

----
BlankLine       ::=  (Space | Tab)* LineBreak
----

And finally the inline content is as follows:

----
InlineContent    ::=  InlineElement*
InlineElement    ::=  Text
                   |  Emphasis
                   |  Strong
                   |  InlineCode
                   |  Link
----

Text is unicode characters without markdown punctuation.

----
Emphasis ::= `"*" Text "*"
Strong = "**" Text "**"
InlineCode  = "`" Text "`"
Link   =  "[" Text "]" "(" Text ")"
----

=== Parsing inline elements

So the text element are plain characters without the puctuation of markdown. First
we write a rule for single char. `noneOf` matches any of the characters that is not specified.
Then we will take many occurences with the requirement of at least one char present - `some`.
`some()` returns a list of chars so we have to map it to string - a `str()` method does that.

[source, java]
----
public void main(String[] args) {
    var textSingle = noneOf('*', '`', '[', ']', '(', ')', '>', '\n');

    var text = some(textSingle).str();

    var r1 = text.parse("this some text");

    out.println(r1.ok());

}
----

Lets test that the punctuation is not parsed

[source, java]
----
public void main(String[] args) {
    var textSingle = noneOf('*', '`', '[', ']', '(', ')', '>', '\n');

    var text = some(textSingle).str();

    var r1 = text.parse("this some *text*");

    if (r1 instanceof Ok(String s, Context ctx)) {
        assert r1.ok().equals("this some ");
        assert ctx.index == ctx.content.indexOf("*");

    } else {
        throw new ParseException("unexpected");
    }

}
----

`some()` succeeded because we have at least one character matching, but
the text got parsed up to the first occurence of '*'. We will handle the error later.
To make the assertions inline we can use convenience methods on the result,
`assertEquals` which throw exception if condition not met.

[source, java]
----
public void main(String[] args) {
    var textSingle = noneOf('*', '`', '[', ']', '(', ')', '>', '\n');

    var text = some(textSingle).str();

    text.assertEquals(
        Context.of("this some *text*"), "this some ");

}
----

Moving to the next elements we can reuse the text rule. But first we
introduce sealed interface with records to hold variants.

[source, java]
----
sealed interface Inline {
    record Text(String value) implements Inline{};
    record Emphasis(String value) implements Inline{};
    record Strong(String value) implements Inline{};
    record Code(String value) implements Inline{};
    record Link(String text, String url) implements Inline{};
}
----

We have to "capture" the char '*' on start and end and text goes in the middle.
The we will take the middle value from `Tuple3` and map it to constructor.

[source, java]
----

var emphasis = seq(c('*'), text, c('*'))
    .map(Ops::takeMiddle).map(Inline.Text::new);

out.println(emphasis.parse("*emphasis*").ok());
----

Result
----
Text[value=emphasis]
----

[source, java]
----
emphasis.assertFails("* emphasis `code`*");
----

In this way we make sure that everything is correct. Text gets only
parsed up to '`', but then we have to end the rule with '*' which is not matched.

The following are the other rules

[source, java]
----
public void main(String[] args) {
    var textSingle = noneOf('*', '`', '[', ']', '(', ')', '>', '\n');
    var text = some(textSingle).str();

    var emphasis = seq(c('*'), text, c('*'))
        .map(Ops::takeMiddle).map(Inline.Emphasis::new);

    emphasis.assertFails("* emphasis `code`*");
    emphasis.assertEquals(Context.of("*text*"),  new Inline.Emphasis("text"));

    var strong = seq(c("**"), text, c("**"))
        .map(Ops::takeMiddle).map(Inline.Strong::new);

    strong.assertFails("** strong *nested* **");
    strong.assertEquals(Context.of("**strong**"), new Inline.Strong("strong"));

    var codeText = some(noneOf('`', '\n')).str();
    var code = seq(c('`'), codeText, c('`'))
        .map(Ops::takeMiddle).map(Inline.Code::new);
    code.assertEquals(Context.of("`code ()*[]`"), new Inline.Code("code ()*[]"));

    var link = seq(c('['), text, c(']'), c('('), text, c(')'))
        .map( tuple6 -> new Inline.Link(tuple6.two(), tuple6.five()));
    link.assertEquals(Context.of("[desc](https://link)"), new Inline.Link("desc", "https://link"));

    var inline = choice(link, strong, code, emphasis, text)
        .map(ch5 ->
            switch (ch5) {
                case One(Inline.Link l) -> (Inline) l;
                case Two(Inline.Strong s) -> (Inline) s;
                case Three(Inline.Code c) -> (Inline) c;
                case Four(Inline.Emphasis e) -> (Inline) e;
                case Five(String t) -> (Inline) new Inline.Text(t);
            }
        );

    var r2 = some(inline).parse("text with **strong** and `code`");
    out.println(r2.ok());

}
----

----
[Text[value=text with ], Strong[value=strong], Text[value= and ], Code[value=code]]
----

=== Parsing blocks

Blocks are separated by two newlines. The more complex case is paragraph because it
has to incorporate stylized text. For headers and links we can just parse simple text.
Starting with paragraph:

[source, java]
----
var paragraph = sepBy(inline, (c('\n').or(some(c(' ')))));
var r3 = paragraph.parse("""
        normal text   *emphasis text*
        **strong text**
        `code text`
        """);
assert r3.isOk();
----

The block quote in this tutorial is a normal text without punctuation, but each  line starts with '>'.

[source, java]
----
 var blockQuote = sepBy(
    seq(c('>'), text)
        .map(Ops::takeSecond),
    c('\n')).map(list -> String.join(" ", list));

var r4 = blockQuote.parse("""
        first line
        second line
        """);
assert r4.ok().equals("first line second line");
----

Then we have to separate the blocks.

[source, java]
----
var blankLine = seq(many(c(' ')), some(c('\n')));

var r5 = sepBy(paragraph, blankLine).parse("""
        paragraph 1

        paragraph 2
        """);
assert r5.ok().size() == 2;
----

Heading is a simple text prefixed by number of '#' s.

[source, java]
----
var heading = seq(
        times(c('#'), 1, 6)
            .map(List::size),
        many(c(' ')),
        text
).map(p -> new Block.HeadingBlock(p.one(), p.three()));

heading.assertEquals(Context.of("## heading 2"), new Block.HeadingBlock(2, "heading 2"));
----

And now we are ready to combine everything together:

[source, java]
----
public void main(String[] args) {
    var textSingle = noneOf('*', '#', '`', '[', ']', '(', ')', '>', '\n');
    var text = some(textSingle).str();

    var emphasis = seq(c('*'), text, c('*'))
        .map(Ops::takeMiddle).map(Inline.Emphasis::new);

    emphasis.assertFails("* emphasis `code`*");
    emphasis.assertEquals(Context.of("*text*"),  new Inline.Emphasis("text"));

    var strong = seq(c("**"), text, c("**"))
        .map(Ops::takeMiddle).map(Inline.Strong::new);

    strong.assertFails("** strong *nested* **");
    strong.assertEquals(Context.of("**strong**"), new Inline.Strong("strong"));

    var codeText = some(noneOf('`', '\n')).str();
    var code = seq(c('`'), codeText, c('`'))
        .map(Ops::takeMiddle).map(Inline.Code::new);
    code.assertEquals(Context.of("`code ()*[]`"), new Inline.Code("code ()*[]"));

    var link = seq(c('['), text, c(']'), c('('), text, c(')'))
        .map( tuple6 -> new Inline.Link(tuple6.two(), tuple6.five()));
    link.assertEquals(Context.of("[desc](https://link)"), new Inline.Link("desc", "https://link"));

    var inline = choice(link, strong, code, emphasis, text)
        .map(ch5 ->
            switch (ch5) {
                case One(Inline.Link l) -> (Inline) l;
                case Two(Inline.Strong s) -> (Inline) s;
                case Three(Inline.Code c) -> (Inline) c;
                case Four(Inline.Emphasis e) -> (Inline) e;
                case Five(String t) -> (Inline) new Inline.Text(t);
            }
        );


    var paragraph = sepBy(inline, (c('\n').or(many(c(' ')))))
         .map(Block.Paragraph::new);
    var r3 = paragraph.parse("""
            normal text   *emphasis text*
            **strong text**
            `code text`
            """);
    assert r3.isOk();

    var blockQuote = sepBy(
        seq(c('>'), text)
            .map(Ops::takeSecond),
        c('\n')).map(list -> String.join(" ", list))
        .map(Block.BlockQoute::new);

    var r4 = blockQuote.parse("""
            first line
            second line
            """);
    assert r4.ok().equals(new Block.BlockQoute("first line second line"));

    var blankLine = seq(many(c(' ')), many(c('\n')));

    var r5 = sepBy(paragraph, blankLine).parse("""
            paragraph 1

            paragraph 2
            """);
    assert r5.ok().size() == 2;

    var heading = seq(
            times(c('#'), 1, 6)
                .map(List::size),
            many(c(' ')),
            text
    ).map(p -> new Block.Heading(p.one(), p.three()));

    heading.assertEquals(Context.of("## heading 2"), new Block.Heading(2, "heading 2"));

    var block = choice(blockQuote, paragraph, heading)
            .map(t3 -> switch(t3) {
                case One(Block.BlockQoute q) -> (Block) q;
                case Two(Block.Paragraph p) -> (Block) p;
                case Three(Block.Heading h) -> (Block) h;
            });

    var markdown = sepBy(block, blankLine);

    var test = """
            This is a **strong** paragraph.
            With `code`

            # Heading 1

            > Some interesting
            > quote
            """;

    out.println(markdown.parse(test).ok());
}
----

The result
----
[Paragraph[elements=[Text[value=This is a ], Strong[value=strong], Text[value=paragraph.], Text[value=With ], Code[value=code]]], Heading[nestLevel=1, text=Heading 1], BlockQoute[text= Some interesting  quote]]
----

Note that we are doing it in iterative way. We started with bottom-most rule
and built up to more complex ones. The experience was much like working in REPL.
This way you can speed up the process significantly.


